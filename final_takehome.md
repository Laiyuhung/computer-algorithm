好的，以下是問題的解答翻譯成繁體中文：

### 1. 0-1 背包問題

#### 動態規劃解法及時間複雜度

0-1 背包問題可以使用動態規劃方法來解決。其關鍵思想是構建一個 DP 表，其中行代表物品，列代表從 0 到最大重量 \( W \) 的重量容量。

假設有 \( n \) 個物品，最大重量容量為 \( W \)。

DP 表的構建如下：
1. **初始化**：如果沒有物品或容量為 0，則最大價值為 0。
2. **填充 DP 表**：對於每個物品 \( i \) 和每個重量 \( w \)，檢查當前物品的重量是否小於或等於 \( w \)。如果是，則有兩個選擇：將該物品包含在背包中或不包含。\( dp[i][w] \) 的值是這兩個選擇中的最大值。

遞推關係為：
\[ dp[i][w] = \max(dp[i-1][w], \text{value}[i] + dp[i-1][w-\text{weight}[i]]) \]

該算法的時間複雜度為 \( O(nW) \)，因為我們要填充大小為 \( n \times W \) 的表。

#### 擬多項式算法

0-1 背包問題的動態規劃解法被稱為擬多項式算法，因為其時間複雜度依賴於輸入的數值（即最大重量 \( W \)），而不是表示輸入所需的位數。在這種情況下，時間複雜度是 \( n \) 和 \( W \) 的多項式，但如果 \( W \) 很大，即使 \( n \) 很小，複雜度也可能很高。

### 2. 從所有節點到 \( t \) 的最短路徑

要在有向圖中找到從所有節點到目標節點 \( t \) 的最短路徑，可以使用 Bellman-Ford 算法（如果圖中包含負權重）或 Dijkstra 算法（對於無負權重的圖）。

Bellman-Ford 算法的操作：
1. 將目標節點 \( t \) 的距離初始化為 0，其它所有節點的距離初始化為無限大。
2. 將所有邊鬆弛 \( |V|-1 \) 次，其中 \( V \) 是頂點數。
3. 檢查是否存在負權重環。

Bellman-Ford 算法的時間複雜度為 \( O(VE) \)，其中 \( V \) 是頂點數，\( E \) 是邊數。

### 3. 使用頂點 "a" 作為源點的 Dijkstra 算法

展示 Dijkstra 算法：
1. 將源點到所有頂點的距離初始化為無限大，源點到自身的距離為 0。
2. 使用優先隊列提取距離最小的頂點。
3. 鬆弛從提取頂點出發的所有邊。
4. 重複直到隊列為空。

使用二叉堆作為優先隊列時，Dijkstra 算法的運行時間為 \( O((V + E) \log V) \)。

### 4. 使用 Prim 算法構建最小生成樹 (MST)

#### a) 使用 Prim 算法構建最小生成樹

1. 初始化優先隊列。
2. 從任意一個頂點開始（例如頂點 \( a \)）。
3. 將起始頂點的所有邊添加到優先隊列。
4. 提取權重最小的邊，將相應的頂點添加到 MST。
5. 將新添加的頂點的所有邊添加到未在 MST 中的頂點。
6. 重複直到所有頂點都包含在 MST 中。

#### b) 運行時間分析

使用優先隊列（二叉堆）時，Prim 算法的運行時間為 \( O(E \log V) \)，其中 \( V \) 是頂點數，\( E \) 是邊數。

如果你有任何具體的圖示或進一步的細節需要包含，請提供它們，以便我可以相應地調整解釋。